<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454269)"/><meta name="altitude" content="15.50570869445801"/><meta name="author" content="walkingstick"/><meta name="created" content="2016-11-25 05:45:51 +0000"/><meta name="latitude" content="31.19436675685622"/><meta name="longitude" content="121.4621836234274"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-05 05:58:53 +0000"/><title>【Gradle for Android】Gradle Fundamentals</title></head><body><div><ol><li><b>Gradle Tasks：</b><br/></li></ol></div><div>Gralde 的核心是Task，Task 的核心是Action。</div><div>参考：<a style="color:#69aa35;" href="evernote:///view/1686536759/s32/5652ab15-b3ce-4160-b479-a62569b76bea/5652ab15-b3ce-4160-b479-a62569b76bea/">【Gradle for Android】User Guide</a></div><div>Task 是有许多Action组成，执行Task的时候，会自动执行这些action。Task也可以依赖于别的Task。然后再执行task的时候，Gradle会确保所有的依赖task都会被执行。</div><div><br/></div><div><ul><li>Gradle Wrapper</li></ul></div><div/><div>一开始就不用下载和安装Gradle，这是因为Gradle Wrapper，它包含了一个shell脚本，能够检查Gradle是否已经安装，判断是否需要安装Gradle。所以只需要有一个Gradle Wrapper，在使用的时候直接调用Gradle命令，执行Gradle脚本就可以为你解决剩余的所有问题。无需在使用Gradle的时候，一开始就先安装Gradle。</div><div><br/></div><div><span>    所以执行./gradlew shell脚本，就会自动初始化Gradle环境了。</span><br/></div><div><br/></div><div><div><ul><li>Gradle Demon</li></ul><div>Gradle启动的时候会花费较多的时间（主要是需要启动一个Java虚拟机），使用Gradle Demon能够减少启动时间。把JVM实例作为Demon运行在后台。AS默认使用了Gradle Demon，但是如果在命令行使用Gradle的话，那就需要手动启用Gradle Demon，以指示Gradle使用Gradle Demon。 </div><div><span>    </span>查看Gradle 的Demon状态：gradle - -status. 停止Gradle demon： Gradle --stop</div></div></div><div><br/></div><div><span>   </span></div><div><ol start="2"><li><b>Groovy 基础</b></li></ol><span/></div><div><div><div><div/></div></div></div><div>能够使用任何的JVM语言来编写Gradle 脚本。但是Gradle是基于Groovy编写的，所以要了解Gradle，先要了解Groovy。so，let‘s start。</div><div><span>    </span><br/></div><div><div><ul><li>Groovy是基于JVM的脚本语言。</li></ul></div></div><div><br/></div><div><div><ul><li>Closure是Groovy语言中的闭包，是一种方便的声明方法的方式，可以当作一个变量一样，赋值，传递等等。 </li></ul><div><br/></div></div><div><ul><li>Groovy方法中的参数还能够接收方法（closure）和参数。</li></ul><div><br/></div></div><div><ul><li>Groovy中Closure如果只有一个参数，那么这个参数默认就成为it。</li></ul><div><br/></div></div><div><div><br/></div><div><ol start="3"><li><b>理解Gradle</b></li></ol></div></div></div><div>正像Closure可以有一个代理对象（delegate object），Gradle中的所有的build 脚本代理给了Project对象。在Gradle DSL 中，所有的关键字都是Project的属性或者方法。</div><div><br/></div><div><ul><li>Gradle中的Task</li></ul></div><div>Gradle中有一个叫task的方法，可以用来声明一个task closure。该方法接收task name作为参数。 Task是有一系列的action 组成的。</div><div>project.task(“myTask1”)</div><div><br/></div><div>由于Gradle中所有的build脚本都代理给了Project对象，所以可以写成</div><div>task(“myTask2”)</div><div><br/></div><div>由于Groovy的语法特性，可以写成：</div><div>task “myTask3”</div><div><br/></div><div>又由于Gradle的特性，可以去掉引号：</div><div>task myTask4</div><div><br/></div><div>于是就有了Gradle中task现在的模样。然后就可以对task中的属性进行赋值。</div><div>myTask4.description=“${task description}”</div><div>myTask4.group=“${taskGroup}”</div><div>myTask4.doLast {println “do this last"}</div><div><br/></div><div>所以可以直接在定义了task之后，直接使用closure 赋值给task，作为task的一个action。这是给task声明简单action的常用方式。</div><div>task myTask5 &lt;&lt; {println “declare a task and give it an action in on stoke”}</div><div><br/></div><div>还可以直接对task 使用closure进行配置，由于 closure 代理给了task对象，所以可以直接进行配置。</div><div>task myTask6  {</div><div><span>    description “"</span><br/></div><div><span>    group “</span>”<br/></div><div><span><span>    doLast{</span><br/></span></div><div><span><span><span>    <span>    println “Here is the action"</span></span><br/></span></span></div><div><span><span><span>    }</span><br/></span></span></div><div>}</div><div><br/></div><div>注意上边closure配置的赋值操作，并没有使用“=”，这是Gradle能够理解的特性，即上边的description其实是一个和属性同名的方法。</div><div><br/></div><div><ul><li>Task Dependencies</li></ul><div>task之间的关系有三种：Depends on，finalize by, and must run after.</div></div><div>Depends on: task A dependsOn task B, 就意味着B不执行完成的话，A无法执行。</div><div><br/></div><div>finalized by: task A is finalizedBy task B, 就是说每次task A 执行完成之后，task B就会接着执行。</div><div><br/></div><div>should run after: task A shouldRunAfter task B 是没有互相依赖的关系的。但是如果同时执行A 和B 两个task的时候，会希望A 在B执行完成之后再去执行。</div><div><br/></div><div>还可以使用同时依赖多个任务。这个时候就要使用赋值符号了，因为要给属性赋值。</div><div><br/></div><div>还有一个特性就是查找所有的task，然后再决定依赖其中的哪些task。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>